// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users_networks.sql

package data

import (
	"context"

	"github.com/kyren223/eko/pkg/snowflake"
)

const getNetworkBannedUsers = `-- name: GetNetworkBannedUsers :many
SELECT
  users.id, users.name, users.public_key, users.description, users.is_public_dm, users.is_deleted,
  users_networks.ban_reason
FROM users_networks
JOIN users ON users.id = users_networks.user_id
WHERE users_networks.network_id = ?
`

type GetNetworkBannedUsersRow struct {
	User      User
	BanReason *string
}

func (q *Queries) GetNetworkBannedUsers(ctx context.Context, networkID snowflake.ID) ([]GetNetworkBannedUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getNetworkBannedUsers, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNetworkBannedUsersRow
	for rows.Next() {
		var i GetNetworkBannedUsersRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.PublicKey,
			&i.User.Description,
			&i.User.IsPublicDM,
			&i.User.IsDeleted,
			&i.BanReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNetworkMemberById = `-- name: GetNetworkMemberById :one
SELECT user_id, network_id, joined_at, is_member, is_admin, is_muted, is_banned, ban_reason, position
FROM users_networks
WHERE users_networks.network_id = ? AND users_networks.user_id = ?
`

type GetNetworkMemberByIdParams struct {
	NetworkID snowflake.ID
	UserID    snowflake.ID
}

func (q *Queries) GetNetworkMemberById(ctx context.Context, arg GetNetworkMemberByIdParams) (UserNetwork, error) {
	row := q.db.QueryRowContext(ctx, getNetworkMemberById, arg.NetworkID, arg.UserID)
	var i UserNetwork
	err := row.Scan(
		&i.UserID,
		&i.NetworkID,
		&i.JoinedAt,
		&i.IsMember,
		&i.IsAdmin,
		&i.IsMuted,
		&i.IsBanned,
		&i.BanReason,
		&i.Position,
	)
	return i, err
}

const getNetworkMembers = `-- name: GetNetworkMembers :many
SELECT
  users.id, users.name, users.public_key, users.description, users.is_public_dm, users.is_deleted,
  users_networks.joined_at,
  users_networks.is_admin,
  users_networks.is_muted
FROM users_networks
JOIN users ON users.id = users_networks.user_id
WHERE users_networks.network_id = ? AND is_member = true
`

type GetNetworkMembersRow struct {
	User     User
	JoinedAt string
	IsAdmin  bool
	IsMuted  bool
}

func (q *Queries) GetNetworkMembers(ctx context.Context, networkID snowflake.ID) ([]GetNetworkMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getNetworkMembers, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNetworkMembersRow
	for rows.Next() {
		var i GetNetworkMembersRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.PublicKey,
			&i.User.Description,
			&i.User.IsPublicDM,
			&i.User.IsDeleted,
			&i.JoinedAt,
			&i.IsAdmin,
			&i.IsMuted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNetwork = `-- name: GetUserNetwork :one
SELECT user_id, network_id, joined_at, is_member, is_admin, is_muted, is_banned, ban_reason, position FROM users_networks
WHERE user_id = ? AND network_id = ?
`

type GetUserNetworkParams struct {
	UserID    snowflake.ID
	NetworkID snowflake.ID
}

func (q *Queries) GetUserNetwork(ctx context.Context, arg GetUserNetworkParams) (UserNetwork, error) {
	row := q.db.QueryRowContext(ctx, getUserNetwork, arg.UserID, arg.NetworkID)
	var i UserNetwork
	err := row.Scan(
		&i.UserID,
		&i.NetworkID,
		&i.JoinedAt,
		&i.IsMember,
		&i.IsAdmin,
		&i.IsMuted,
		&i.IsBanned,
		&i.BanReason,
		&i.Position,
	)
	return i, err
}

const getUserNetworks = `-- name: GetUserNetworks :many
SELECT networks.id, networks.owner_id, networks.name, networks.icon, networks.bg_hex_color, networks.fg_hex_color, networks.is_public, users_networks.position FROM networks
JOIN users_networks ON networks.id = users_networks.network_id
WHERE users_networks.user_id = ?
ORDER BY users_networks.position
`

type GetUserNetworksRow struct {
	Network  Network
	Position *int64
}

func (q *Queries) GetUserNetworks(ctx context.Context, userID snowflake.ID) ([]GetUserNetworksRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserNetworks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserNetworksRow
	for rows.Next() {
		var i GetUserNetworksRow
		if err := rows.Scan(
			&i.Network.ID,
			&i.Network.OwnerID,
			&i.Network.Name,
			&i.Network.Icon,
			&i.Network.BgHexColor,
			&i.Network.FgHexColor,
			&i.Network.IsPublic,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setMember = `-- name: SetMember :one
INSERT INTO users_networks (
  user_id, network_id,
  is_member, is_admin, is_muted,
  is_banned, ban_reason, position
) VALUES (
  ?1, ?2,
  ?3, ?4, ?5,
  ?6, ?7,
  CASE
    WHEN ?3 = false THEN NULL
    ELSE (SELECT COUNT(*) FROM users_networks WHERE user_id = ?1)
  END
)
ON CONFLICT DO 
UPDATE SET
  is_member = EXCLUDED.is_member, is_admin = EXCLUDED.is_admin, is_muted = EXCLUDED.is_muted,
  is_banned = EXCLUDED.is_banned, ban_reason = EXCLUDED.ban_reason, position = EXCLUDED.position
WHERE user_id = EXCLUDED.user_id AND network_id = EXCLUDED.network_id
RETURNING user_id, network_id, joined_at, is_member, is_admin, is_muted, is_banned, ban_reason, position
`

type SetMemberParams struct {
	UserID    snowflake.ID
	NetworkID snowflake.ID
	IsMember  bool
	IsAdmin   bool
	IsMuted   bool
	IsBanned  bool
	BanReason *string
}

func (q *Queries) SetMember(ctx context.Context, arg SetMemberParams) (UserNetwork, error) {
	row := q.db.QueryRowContext(ctx, setMember,
		arg.UserID,
		arg.NetworkID,
		arg.IsMember,
		arg.IsAdmin,
		arg.IsMuted,
		arg.IsBanned,
		arg.BanReason,
	)
	var i UserNetwork
	err := row.Scan(
		&i.UserID,
		&i.NetworkID,
		&i.JoinedAt,
		&i.IsMember,
		&i.IsAdmin,
		&i.IsMuted,
		&i.IsBanned,
		&i.BanReason,
		&i.Position,
	)
	return i, err
}

const swapUserNetworks = `-- name: SwapUserNetworks :exec
UPDATE users_networks SET
  position = CASE
    WHEN position = ?1 THEN ?2
    WHEN position = ?2 THEN ?1
  END
WHERE user_id = ?3 AND position IN (?1, ?2)
`

type SwapUserNetworksParams struct {
	Pos1   *int64
	Pos2   *int64
	UserID snowflake.ID
}

func (q *Queries) SwapUserNetworks(ctx context.Context, arg SwapUserNetworksParams) error {
	_, err := q.db.ExecContext(ctx, swapUserNetworks, arg.Pos1, arg.Pos2, arg.UserID)
	return err
}
