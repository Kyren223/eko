// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: members.sql

package data

import (
	"context"
	"strings"

	"github.com/kyren223/eko/pkg/snowflake"
)

const filterUsersInNetwork = `-- name: FilterUsersInNetwork :many
SELECT user_id FROM members
WHERE network_id = ? AND user_id IN (/*SLICE:users*/?)
`

type FilterUsersInNetworkParams struct {
	NetworkID snowflake.ID
	Users     []snowflake.ID
}

func (q *Queries) FilterUsersInNetwork(ctx context.Context, arg FilterUsersInNetworkParams) ([]snowflake.ID, error) {
	query := filterUsersInNetwork
	var queryParams []interface{}
	queryParams = append(queryParams, arg.NetworkID)
	if len(arg.Users) > 0 {
		for _, v := range arg.Users {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:users*/?", strings.Repeat(",?", len(arg.Users))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:users*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []snowflake.ID
	for rows.Next() {
		var user_id snowflake.ID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannedMembers = `-- name: GetBannedMembers :many
SELECT
  users.id, users.name, users.public_key, users.description, users.is_public_dm, users.is_deleted, users.last_activity,
  members.user_id, members.network_id, members.joined_at, members.is_member, members.is_admin, members.is_muted, members.is_banned, members.ban_reason
FROM members
JOIN users ON users.id = members.user_id
WHERE network_id = ? AND is_banned = true
`

type GetBannedMembersRow struct {
	User   User
	Member Member
}

func (q *Queries) GetBannedMembers(ctx context.Context, networkID snowflake.ID) ([]GetBannedMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getBannedMembers, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBannedMembersRow
	for rows.Next() {
		var i GetBannedMembersRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.PublicKey,
			&i.User.Description,
			&i.User.IsPublicDM,
			&i.User.IsDeleted,
			&i.User.LastActivity,
			&i.Member.UserID,
			&i.Member.NetworkID,
			&i.Member.JoinedAt,
			&i.Member.IsMember,
			&i.Member.IsAdmin,
			&i.Member.IsMuted,
			&i.Member.IsBanned,
			&i.Member.BanReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberById = `-- name: GetMemberById :one
SELECT user_id, network_id, joined_at, is_member, is_admin, is_muted, is_banned, ban_reason FROM members
WHERE network_id = ? AND user_id = ?
`

type GetMemberByIdParams struct {
	NetworkID snowflake.ID
	UserID    snowflake.ID
}

func (q *Queries) GetMemberById(ctx context.Context, arg GetMemberByIdParams) (Member, error) {
	row := q.db.QueryRowContext(ctx, getMemberById, arg.NetworkID, arg.UserID)
	var i Member
	err := row.Scan(
		&i.UserID,
		&i.NetworkID,
		&i.JoinedAt,
		&i.IsMember,
		&i.IsAdmin,
		&i.IsMuted,
		&i.IsBanned,
		&i.BanReason,
	)
	return i, err
}

const getNetworkMembers = `-- name: GetNetworkMembers :many
SELECT
  users.id, users.name, users.public_key, users.description, users.is_public_dm, users.is_deleted, users.last_activity,
  members.user_id, members.network_id, members.joined_at, members.is_member, members.is_admin, members.is_muted, members.is_banned, members.ban_reason
FROM members
JOIN users ON users.id = members.user_id
WHERE network_id = ? AND is_member = true
`

type GetNetworkMembersRow struct {
	User   User
	Member Member
}

func (q *Queries) GetNetworkMembers(ctx context.Context, networkID snowflake.ID) ([]GetNetworkMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getNetworkMembers, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNetworkMembersRow
	for rows.Next() {
		var i GetNetworkMembersRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.PublicKey,
			&i.User.Description,
			&i.User.IsPublicDM,
			&i.User.IsDeleted,
			&i.User.LastActivity,
			&i.Member.UserID,
			&i.Member.NetworkID,
			&i.Member.JoinedAt,
			&i.Member.IsMember,
			&i.Member.IsAdmin,
			&i.Member.IsMuted,
			&i.Member.IsBanned,
			&i.Member.BanReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNetworks = `-- name: GetUserNetworks :many
SELECT networks.id, networks.owner_id, networks.name, networks.icon, networks.bg_hex_color, networks.fg_hex_color, networks.is_public FROM networks
JOIN members ON networks.id = members.network_id
WHERE members.user_id = ? AND members.is_member = true
`

func (q *Queries) GetUserNetworks(ctx context.Context, userID snowflake.ID) ([]Network, error) {
	rows, err := q.db.QueryContext(ctx, getUserNetworks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Network
	for rows.Next() {
		var i Network
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Icon,
			&i.BgHexColor,
			&i.FgHexColor,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setMember = `-- name: SetMember :one
INSERT INTO members (
  user_id, network_id,
  is_member, is_admin, is_muted,
  is_banned, ban_reason
) VALUES (
  ?1, ?2,
  ?3, ?4, ?5,
  ?6, ?7
)
ON CONFLICT DO
UPDATE SET
  is_member = EXCLUDED.is_member, is_admin = EXCLUDED.is_admin, is_muted = EXCLUDED.is_muted,
  is_banned = EXCLUDED.is_banned, ban_reason = EXCLUDED.ban_reason
WHERE user_id = EXCLUDED.user_id AND network_id = EXCLUDED.network_id
RETURNING user_id, network_id, joined_at, is_member, is_admin, is_muted, is_banned, ban_reason
`

type SetMemberParams struct {
	UserID    snowflake.ID
	NetworkID snowflake.ID
	IsMember  bool
	IsAdmin   bool
	IsMuted   bool
	IsBanned  bool
	BanReason *string
}

func (q *Queries) SetMember(ctx context.Context, arg SetMemberParams) (Member, error) {
	row := q.db.QueryRowContext(ctx, setMember,
		arg.UserID,
		arg.NetworkID,
		arg.IsMember,
		arg.IsAdmin,
		arg.IsMuted,
		arg.IsBanned,
		arg.BanReason,
	)
	var i Member
	err := row.Scan(
		&i.UserID,
		&i.NetworkID,
		&i.JoinedAt,
		&i.IsMember,
		&i.IsAdmin,
		&i.IsMuted,
		&i.IsBanned,
		&i.BanReason,
	)
	return i, err
}
